两者涉及 `const` 在指针中的不同用法，是易混淆但非常重要的概念。

---

### 1. 指向常量的指针（Pointer to const）
```cpp
const int a = 3;
int b = 4;
const int *c = &a;  // c 是指向常量的指针
*c = 10;             //  不允许：不能通过 c 修改 a 的值（因为 a 是常量）
c = &b;             //  允许：c 可以指向其他变量（甚至是「非常量」的 b）
*c = 10;            //  仍然不允许！
```
- **关键点**：`const int*` 表示「指针指向的内容不可修改」，但指针本身可以指向其他地址。
- **指向非常量时**：即使 `b` 是「非常量」，但通过 `const int*` 指针访问时，编译器会认为它指向的是「常量」，因此不能通过 `*c` 修改 `b`。
  
  ```cpp
  int b = 4;
  const int *c = &b;
  *c = 10;  // 编译错误：即使 b 是「非常量」，通过 c 也无法修改
  ```

### 2. 常量指针（const Pointer）
```cpp
int a = 3;
int b = 4;
int* const d = &a;  // d 是「常量指针」（指针本身不可修改）
d = &b;                 // 不允许：d 是常量指针，不能指向其他地址
*d = 10;                //  允许：可以修改 d 指向的内容（前提是 a 不是常量）
```

- **关键点**：`int* const` 表示「指针本身是常量」（不能指向其他地址），但指向的内容是否可修改，取决于目标的 `const` 属性。
  
  ```cpp
  const int a = 3;
  const int* const d = &a;  // 指针是常量，且指向的内容是常量
  *d = 10;                          //  错误：a 是常量
  ```

| 类型               | 语法               | 能否修改指针指向 | 能否通过指针修改指向的值 |
| ------------------ | ------------------ | ---------------- | ------------------------ |
| 指向常量的指针     | `const int*`       | ✅                | ❌                        |
| 常量指针           | `int* const`       | ❌                | 取决于目标的 `const`     |
| 指向常量的常量指针 | `const int* const` | ❌                | ❌                        |

---

### 3. 关键规则
- **`const` 在 `*` 左侧**：指向的内容是常量（如 `const int*`）。
- **`const` 在 `*` 右侧**：指针本身是常量（如 `int* const`）。
- **双重 `const`**：`const int* const` 表示指针和指向的内容都是常量。

在 C++ 中，`const` 在指针中的不同位置（左侧、右侧、双重）对应不同的语义，它们的用途直接关系到代码的 **安全性**、**设计意图** 和 **资源管理**。以下是它们的具体用途和典型场景：

---

### 4. 用途

#### 1. `const` 在 `*` 左侧：`const int* ptr`（指向常量的指针）

   - **用途**：**保护指向的数据不被修改**，表明「通过该指针访问的数据是只读的」。
   - **典型场景**：
     - **函数参数传递**：  
       当函数不需要修改传入的数据时，用 `const int*` 明确告知调用者数据不会被修改，同时避免意外修改。
       
       ```cpp
       void print_data(const int* data, int size) {
           for (int i = 0; i < size; i++) {
               std::cout << data[i] << " ";  // ✅ 读取数据
               // data[i] = 10;              // ❌ 禁止修改
           }
       }
       ```
     - **访问只读资源**：  
       如配置文件、硬件寄存器等需要保护的数据。
       
       ```cpp
       const char* config_file = "settings.conf";  // 配置文件内容不可修改
       ```

   - **关键优势**：  
     即使指针指向的是「非常量」数据（如 `int x = 5; const int* p = &x;`），通过 `p` 也无法修改 `x`。这可以强制约束代码行为，避免误操作。

---

#### 2. **`const` 在 `*` 右侧：`int* const ptr`（常量指针）**
   - **用途**：**固定指针的指向**，确保指针本身不指向其他地址。
   - **典型场景**：
     - **资源句柄管理**：  
       需要确保指针始终指向某个资源（如动态分配的内存、硬件寄存器地址）。
       ```cpp
       int* const buffer = new int[100];  // buffer 指针不可修改
       // buffer = nullptr;             // ❌ 禁止修改指针指向
       delete[] buffer;                 // ✅ 但可以释放它指向的内存
       ```
     - **硬件编程**：  
       操作固定地址的硬件寄存器时，指针必须稳定。
       ```cpp
       volatile uint32_t* const GPIO_PORT = (uint32_t*)0x40020000;  // GPIO 端口地址固定
       *GPIO_PORT = 0xFF;  // ✅ 允许修改寄存器值
       ```

   - **关键优势**：  
     防止指针被意外修改（如误赋值、越界操作），增强代码可靠性。

---

#### 3. **双重 `const`：`const int* const ptr`（指向常量的常量指针）**
   - **用途**：**同时保护指针和指向的数据**，既不能修改指针指向，也不能通过指针修改数据。
   - **典型场景**：
     - **全局常量数据**：  
       定义全局只读数据，确保数据不可修改且指针指向固定。
       ```cpp
       const float* const PI = new const float(3.1415926f);  // 双重保护
       // PI = nullptr;     // ❌ 禁止修改指针
       // *PI = 3.14;       // ❌ 禁止修改数据
       ```
     - **只读硬件映射**：  
       操作只读的硬件寄存器时，确保地址和数据均不可变。
       
       ```cpp
       const volatile uint32_t* const READ_ONLY_REG = (uint32_t*)0x40000000;
       uint32_t value = *READ_ONLY_REG;  // ✅ 仅读取
       ```
   - **关键优势**：  
     提供最高级别的保护，适用于需要严格约束的场景。

---

### 5. **综合对比表**
| 类型                   | 语法                   | 用途               | 可修改指针指向？ | 可修改指向的值？   |
| ---------------------- | ---------------------- | ------------------ | ---------------- | ------------------ |
| **指向常量的指针**     | `const int* ptr`       | 保护数据不被修改   | ✅                | ❌                  |
| **常量指针**           | `int* const ptr`       | 固定指针指向       | ❌                | 取决于目标是否常量 |
| **指向常量的常量指针** | `const int* const ptr` | 同时保护指针和数据 | ❌                | ❌                  |

---

### 6. **实际开发中的意义**
1. **代码自文档化**：  
   通过 `const` 明确表达设计意图，例如 `const int*` 告诉其他开发者“此数据不应被修改”。
2. **防止误操作**：  
   编译器会检查违反 `const` 约束的操作，提前拦截潜在错误（如意外修改只读数据）。
3. **优化可能性**：  
   编译器可能利用 `const` 信息进行优化（如将常量数据放入只读内存段）。
4. **兼容性**：  
   可以安全地将「非常量」数据传递给 `const` 指针参数（如 `void func(const int* p)` 可以接受 `int*` 参数）。

---

### 7. **经典例子**
```cpp
// 1. 保护函数参数
void process_data(const int* data, int size) {
    // 只能读取 data，不能修改
}

// 2. 固定资源指针
char* const log_buffer = new char[1024];
// log_buffer = other_buffer; // ❌ 禁止

// 3. 全局常量
const char* const VERSION = "1.0.0";
```

合理使用 `const` 指针，可以让代码更健壮、更易维护！ 🛠️