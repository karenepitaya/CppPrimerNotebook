这个问题的根源在于C/C++的**类型声明语法规则**，它遵循着一个重要的规律：

>   **声明的写法应当看起来像你使用这个类型时的样子。**

也就是说，`typedef`的用法其实是在“模仿”正常声明变量的方式，只是把变量变成了类型别名。我们一步步剖析这个问题。

------

### 一、平常定义一个数组

```cpp
int arr[10];
```

这段代码的意思是：定义一个名叫`arr`的数组，它包含10个`int`类型的元素。

注意，**方括号 `[10]` 是跟在变量名 `arr` 后面的**，不是跟在 `int` 后面。
 C/C++数组类型的语法就是这样：**类型说明符 + 变量名 + [大小]**。

------

### 二、用`typedef`给这个类型起别名

我们想给“包含10个`int`的数组”这个类型起一个别名，比如叫`array_int`。

我们想让`array_int`变成一种类型，以后可以写：

```cpp
array_int arr;  // 等同于 int arr[10];
```

按照**“像声明变量一样”**的语法，把变量名换成类型名：

```cpp
typedef int array_int[10];
```

解读：

-   这看起来就像你在定义一个数组：`int arr[10];`
-   只是现在不是定义一个变量`arr`，而是定义一个类型别名`array_int`，它表示**一个包含10个`int`的数组类型**。

也就是说：

```cpp
typedef  原来的类型  新的类型名;
```

结合`int arr[10];`，把`arr`换成类型名`array_int`，得到：

```cpp
typedef int array_int[10];
```

------

### 三、错误示例分析：`typedef int[10] array_int;`

这个写法不合法，因为：

-   `int[10]`在语法上不是一个完整的类型说明符，数组的`[10]`必须和某个“变量名”绑定在一起，写在变量名后面。
-   `typedef`不是“把一段类型表达式包装成一个类型”，它是模仿变量声明。

所以，`typedef`的核心思路是：

>   你写出来的东西要看起来像是在声明一个变量。

写成`typedef int[10] array_int;`会让编译器迷惑，它不知道`int[10]`是啥，因为类型说明符部分（`int`）和数组大小`[10]`是分离的，缺少一个“变量名”把它们连起来。

------

### 四、对比指针的例子

指针类型别名：

```cpp
typedef int* int_ptr;
int_ptr p;  // 等价于 int *p;
```

`int_ptr`这个别名看起来就像`int *p;`中的`p`一样。

------

### 五、总结规律：**typedef声明规则**

1.  `typedef` 语句要写得像一个变量声明，只不过变量名变成了类型别名。
2.  数组类型，方括号必须跟在变量名或类型别名后面。

按照这个理解，你以后见到复杂的`typedef`，就可以先把它看成一个变量声明，再把变量名理解成类型名。

比如：

```cpp
typedef int (*func_ptr)(int, int);
```

理解步骤：

1.  先看`int (*p)(int, int);`，这声明了一个变量`p`，它是个**函数指针**。
2.  把`p`换成`func_ptr`，就成了`typedef`类型别名。

本质上，`typedef`只是个“换名工具”，但换名的写法必须模仿变量声明的样子。