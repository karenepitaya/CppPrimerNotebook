## 1. 为什么 `push_back` 等改变 `vector` 容量的操作会使迭代器失效？

### (1) `vector` 的内存模型：

`vector` 的底层实现是一个**动态数组**，其特点是：

-   元素存储在**连续的内存空间**中。
-   当元素数量超过当前容量时，`vector` 会**申请一块更大的新内存区域**，然后**把原来的元素全部拷贝到新区域**。
-   旧的内存区域会被释放。

### (2) 迭代器的本质：

`vector` 的迭代器本质上是一个**指向元素的指针**。

-   比如：

    ```cpp
    std::vector<int> v{1, 2, 3};
    auto it = v.begin();  // it 指向第一个元素，即 &v[0]
    ```

### (3) `push_back` 导致迭代器失效的原因：

假设 `v` 容量为 3，现在再 `push_back(4)`：

```cpp
v.push_back(4);
```

由于容量不够，`vector` 申请了新的内存，拷贝了原来的 `{1, 2, 3}` 到新内存，新区域的地址和旧区域不同。

但是，`it` 仍然保存着**旧区域的地址**，此时：

```cpp
std::cout << *it << std::endl;  // 未定义行为，可能崩溃
```

`it` 变成了**野指针**。

**改变容量导致迭代器失效，是因为底层内存位置改变了，原来的迭代器指针指向的内存已经无效。**

------

## 2. 删除元素可以吗？

### 删除元素也可能导致迭代器失效，但规则不同：

#### (1) `erase()`、`pop_back()` 导致的迭代器失效规则：

-   `erase(pos)`：使得**被删除的元素位置及其之后的所有迭代器失效**。
-   `pop_back()`：使得**最后一个元素的迭代器失效**。

原因：

-   `erase()` 删除某位置的元素后，`vector` 会**将后面的元素向前移动**，原来指向后面元素的迭代器失效了。
-   `pop_back()` 删掉最后一个元素，**指向最后一个元素的迭代器失效**。

#### (2) 示例：

```cpp
std::vector<int> v{1, 2, 3, 4, 5};
auto it = v.begin() + 2;  // 指向3
v.erase(v.begin() + 1);   // 删除2
std::cout << *it << std::endl;  // 未定义行为
```

这里 `erase()` 使得 `it` 失效，因为 `erase()` 把 `3` 移到了 `2` 的位置，`it` 还指向原来的位置。

## 3. 总结：

| 操作             | 导致的迭代器失效情况                       |
| ---------------- | ------------------------------------------ |
| `push_back()`    | 使所有迭代器失效（容量不足时重新分配内存） |
| `erase(pos)`     | 使 `pos` 及其之后的所有迭代器失效          |
| `pop_back()`     | 使最后一个元素的迭代器失效                 |
| 访问元素不变操作 | 不会使迭代器失效                           |

## 4. 经验建议：

-   **谨记, 但凡是使用了迭代器的循环体, 都不要向迭代器所属容器添加元素**,删除时也要慎重