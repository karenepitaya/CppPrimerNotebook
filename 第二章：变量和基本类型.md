# 变量和基本类型

## 基本内置类型

### 符号

- signed

- unsigned

### arithmetic type

- integral

	- bool（true or false）

	- char：8bits（minimal）

	- wchar_t：16bits（minimal）

	- char16_t：16bits（minimal）

	- char32_t：32bits（minimal）

	- short：16bits（minimal）

	- int：16bits（minimal）

	- long：32bits（minimal）

	- long long：64bits（minimal）

- float

	- float：6位有效数字

	- double：10位有效数字

	- long double：10位有效数字

### void

## 字面值常量

### 整形字面值常量

- 十进制默认是int、long、long long中尺寸最小的那个
20、18、8298

- 八进制、十六进制默认也是，但是有可能是unsigned
024 /*八进制*/、0x14/*十六进制*/

### 浮点型字面值常量

- 默认是double
3.14、.001、0.14e3

### 字符和字符串

- 字符字面值：
'a' //字符字面值

- 字符串字面值：
"Hello" //字符串字面值

- 转义序列

	- 控制字符

		- 换行符：\n

		- 横向制表符：\t

		- 纵向制表符：\v

		- 报警符：\a

		- 退格符：\b

		- 回车符：\r

		- 进纸符：\f

	- 特殊字符

		- \"  \'  \?  \\ 

	- 泛化的转义序列

		- \x后紧跟1个或者多个16进制数字

		- \后紧跟1/2/3个8进制数

### 布尔字面值

- true

- false

### 指针字面值

- nullptr

### 指定字面值的类型

-  

- 1、使用大写L/U/F，避免混淆
2、注意L在字符和数字字面值中的含义不同

## 变量

### 初始化

- 初始化与赋值的区别

	- 初始化的含义是创建变量时赋予一个初始值

	- 赋值的含义是把对象的当前值擦除，以一个新值代替。

- 列表初始化

	- int units_sold = {0};

	- int units_sold{0};

	- 使用列表初始化的内置变量，当初始值有丢失信息的风险时，编译器会报错
long double ld = 3.1415926;
int a{ld}, b = {ld}; //报错，初始信息有丢失的风险
int c(ld), d = ld;    //不会报错，值有丢失

- 默认初始化

	- 定义变量时没有指定初始值，此时变量会被赋予默认值，这由变量类型和定义的位置决定

	- 1、在函数外部定义的内置类型未被显式初始化，默认值为0
2、在函数内部定义的内置类型未被显式初始化，该值不被初始化，未定义，直接使用则报错
3、类规定了自己的默认初始化

### 变量提供了一个具名的、可供程序操控的存储空间。C++的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能够存储的值的范围，以及变量能够参与的运算。对于C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。

### 声明与定义

- 为了支持分离式编译，C++将declaration和definition区分开来

- declaration使得名字为程序所知

	- 声明规定了变量的类型和名字

- definition负责创建与名字关联的实体

	- 定义也规定了变量的类型和名字

	- 定义同时还申请了存储空间

	- 还可能为变量赋初始值

- 如果声明变量而不定义（不申请存储空间）：
extern int i;     //声明i，而非定义i
int i;                 //声明并定义i

- 变量只能被定义一次，但是可以被多次声明

	- 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误

### 标识符

- 由字母数字和下划线组成，数字不能做开头，长度没有限制，但是对大小写敏感

- 1、关键字不能用

- 2、__ABC或者_ABC类的不能用，这是标准库的标识符

- 3、函数体外的标识符不能用下划线开头

- 4、变量用小写

- 5、自定义类大写开头，TuoFengShi

- 6、标识符有多个单词用_分割或者驼峰命名规范

## 分支主题 3

## 复合类型

### 引用（reference），
即对象的别名

- int ival = 1024;
int &refVal = ival;

- 引用与初始值绑定，无法绑定到其他对象，因此引用必须初始化

- 由于引用只能与对象绑定，引用本身不是对象，所以不能定义引用的引用

- 饮用的类型要跟其绑定的对象严格匹配

- 报错实例：
1、int &refVal; // 引用必须初始化
2、int &refVal = 1.01;  //引用只能与对象绑定
3、double ival = 1.01;
      int &refVal = ival;  //引用类型与对象类型不符

### 指针（pointer），即"指向（point to）"对象的类型

- int dp, *dp;
int ival =42;
int *dval = &ival;

- 指针的特点

	- 指针存放对象的地址，因为引用不是对象，因此不能定义指向引用的指针

	- 指针在其生命周期内可以指向不同的对象，因此在定义时允许不初始化，它有默认值”nullptr“

	- 指针的类型和它所指向的对象类型严格匹配

	- 访问空指针是不被允许的

	- 指针本身就是对象，所以允许创建指针的指针

	- 如果指针指向了一个对象，则允许使用解引用符（”*“）访问对象，就如同直接访问对象，且允许指针通过解引用符来重新为所指对象赋值

- 空指针（nullptr）

	- 不指向任何对象：
int *pt = nullptr;  // C++11引入
int *pt = 0; 
int *pt = NULL; // need #include <cstdlib>
三者等价，生成空指针

	- 在使用指针前首先检查是否为空

## 自由主题

## int、short、long、long long都是带符号的，加unsigned才表示不带符号：
1、int
2、unsigned int

## char有三种：
1、char
2、signed char
3、unsigned char
但是表现形式只有两种，char具体表现为signed还是unsigned由编译器决定

## 1、当数值不可能为负时，用unsigned
2、整数小范围用int，超过int范围直接用long long
3、在算式表达式中不要用char或者bool，这两种的值在不同机器上是不明确的，需要一个很小的数时用signed char或者unsigned char
4、浮点数直接用double

##  

## "通婚"忌讳: 有符号数和无符号数混用, 编译器永远会先变成unsigned再说,引发错误

## compound type：基于其他类型定义的类型

## 右值引用（rvalue reference）：C++11新增

## gcc download site:
https://winlibs.com/#download-release

## NULL是一个预处理变量（preprocessor variable），它在<cstdlib>中定义；
预处理器是允许于编译前的一段程序，预处理器变量不属于命名空间std，当用到预处理器变量时，预处理器自动将其替换为实际值。

